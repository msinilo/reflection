#ifndef STR_ID_H
#define STR_ID_H

#include "reflection/Reflection.h"
#include "core/CRC32.h"
#include "rdestl/fixed_substring.h"

namespace rde
{
// String + CRC pair.
// All comparison operators compare CRCs first and perform full string test only 
// if needed.
class StrId
{
public:
	typedef fixed_substring<char, 64>	StrType;

	StrId() {}
	StrId(const char* str)
	:	m_crc(str)
#if !RDE_REFLECTION_HASHES_ONLY
		, m_str(str)
#endif
	{ }
	template<size_t M>
	StrId(const fixed_substring<char, M>& str)
#if !RDE_REFLECTION_HASHES_ONLY
	:	m_str(str)
#endif
	{
		m_crc = str.data();
	}

	// Copy ctor + assignment operator - generated by compiler.

	void operator=(const char* str)
	{
#if !RDE_REFLECTION_HASHES_ONLY
		m_str = str;
#endif
		m_crc = str;
	}

	bool operator==(const StrId& rhs) const
	{
		return m_crc == rhs.m_crc 
#if !RDE_REFLECTION_HASHES_ONLY
			&& m_str == rhs.m_str
#endif
			;
	}
	bool operator!=(const StrId& rhs) const
	{
		return !(*this == rhs);
	}
#if RDE_REFLECTION_HASHES_ONLY
	const char* GetStr() const	{ return "<undefined>"; }
#else
	const char* GetStr() const	{ return m_str.data(); }
#endif
	uint32_t GetId() const		{ return m_crc.GetValue(); }

private:
	CRC32	m_crc;
#if !RDE_REFLECTION_HASHES_ONLY
	StrType	m_str;
#endif
};

}

#endif
